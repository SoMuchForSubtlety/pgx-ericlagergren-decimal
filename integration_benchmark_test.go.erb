// Code generated by erb. DO NOT EDIT.

package decimal_test

import (
	"context"
	"testing"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5"
	"github.com/ericlagergren/decimal/sql/postgres"
	pgxdecimal "github.com/SoMuchForSubtlety/pgx-ericlagergren-decimal"
)

<%
  [
    ["numeric", ["int64", "float64", "pgtype.Numeric", "postgres.Decimal", "pgxdecimal.Decimal"], [[1, 1], [1, 10], [10, 1], [100, 10]]],
  ].each do |pg_type, go_types, rows_columns|
%>
<% go_types.each do |go_type| %>
<% rows_columns.each do |rows, columns| %>
func BenchmarkQueryDecode_PG_<%= pg_type %>_to_Go_<%= go_type.gsub(/\W/, "_") %>_<%= rows %>_rows_<%= columns %>_columns(b *testing.B) {
	defaultConnTestRunner.RunTest(context.Background(), b, func(ctx context.Context, _ testing.TB, conn *pgx.Conn) {
    b.ResetTimer()
    var v [<%= columns %>]<%= go_type %>
    for i := 0; i < b.N; i++ {
      rows, _ := conn.Query(ctx, `select <% columns.times do |col_idx| %><% if col_idx != 0 %>, <% end %>n::<%= pg_type %> + <%= col_idx%><% end %> from generate_series(1, <%= rows %>) n`)
      _, err := pgx.ForEachRow(
        rows,
        []interface{}{<% columns.times do |col_idx| %><% if col_idx != 0 %>, <% end %>&v[<%= col_idx%>]<% end %>},
        func() error { return nil },
      )
      if err != nil {
        b.Fatal(err)
      }
    }
  })
}
<% end %>
<% end %>
<% end %>

<%
  [
    ["numeric", ["postgres.Decimal"], [[1, 1], [1, 10], [10, 1], [100, 10]]],
  ].each do |pg_type, go_types, rows_columns|
%>
<% go_types.each do |go_type| %>
<% rows_columns.each do |rows, columns| %>
func BenchmarkQueryDecode_PG_<%= pg_type %>_to_Go_<%= go_type.gsub(/\W/, "_") %>_<%= rows %>_rows_<%= columns %>_columns_with_Register(b *testing.B) {
	defaultConnTestRunner.RunTest(context.Background(), b, func(ctx context.Context, _ testing.TB, conn *pgx.Conn) {
    b.ResetTimer()
    var v [<%= columns %>]<%= go_type %>
    for i := 0; i < b.N; i++ {
      rows, _ := conn.Query(ctx, `select <% columns.times do |col_idx| %><% if col_idx != 0 %>, <% end %>n::<%= pg_type %> + <%= col_idx%><% end %> from generate_series(1, <%= rows %>) n`)
      _, err := pgx.ForEachRow(
        rows,
        []interface{}{<% columns.times do |col_idx| %><% if col_idx != 0 %>, <% end %>&v[<%= col_idx%>]<% end %>},
        func() error { return nil },
      )
      if err != nil {
        b.Fatal(err)
      }
    }
  })
}
<% end %>
<% end %>
<% end %>
